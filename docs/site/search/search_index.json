{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PDES-MAS documentation page! PDES-MAS is a framework and a distributed simulation engine for multi Agent-based system models (MAS). See also Our homepage . Or, view the source code on Github This site is still under construction. Any issues will be welcomed and treated carefully. Overview PDES-MAS is a framework and a distributed simulation engine for multi Agent-based system models (MAS). PDES-MAS represents research efforts and investments of almost 20 years. PDES-MAS has been a pioneering system that has made innovative contributions along different strands: Distributed Simulation of MAS: PDES-MAS was one of the earliest efforts to address the problem of distributed simulation of MAS models and develop a generic distributed simulation engine specific for MAS. Event-Driven Simulation of Agents: Contrary to the vast majority of the simulation engines for agent models that are time-driven, PDES-MAS supports a purely event-driven modelling approach. Optimistic Synchronisation for MAS. PDES-MAS has been the first system to investigate optimistic synchronisation for MAS distributed simulations. Data-Centric Simulation, Linking Models to Data: PDES-MAS has demonstrated a method for accessing data from within a simulation using different forms of queries. It has been the first to address the problem of synchronised range queries. Space-Time Memory: PDES-MAS implements a synchronised Distributed Shared Memory approach for state distribution and access. Contrary to most systems that utilise proxies and push methods for consistency, PDES-MAS proposes a pull approach without the use of proxies. Distributed Virtual Environments: PDES-MAS has been the first one to address the problems of state partition, interest management and synchronisation in an integrated, adaptive and fully transparent manner. Get PDES-MAS Clone from github repository using git: git clone https://github.com/PDES-MAS/PDES-MAS.git","title":"Welcome"},{"location":"#overview","text":"PDES-MAS is a framework and a distributed simulation engine for multi Agent-based system models (MAS). PDES-MAS represents research efforts and investments of almost 20 years. PDES-MAS has been a pioneering system that has made innovative contributions along different strands: Distributed Simulation of MAS: PDES-MAS was one of the earliest efforts to address the problem of distributed simulation of MAS models and develop a generic distributed simulation engine specific for MAS. Event-Driven Simulation of Agents: Contrary to the vast majority of the simulation engines for agent models that are time-driven, PDES-MAS supports a purely event-driven modelling approach. Optimistic Synchronisation for MAS. PDES-MAS has been the first system to investigate optimistic synchronisation for MAS distributed simulations. Data-Centric Simulation, Linking Models to Data: PDES-MAS has demonstrated a method for accessing data from within a simulation using different forms of queries. It has been the first to address the problem of synchronised range queries. Space-Time Memory: PDES-MAS implements a synchronised Distributed Shared Memory approach for state distribution and access. Contrary to most systems that utilise proxies and push methods for consistency, PDES-MAS proposes a pull approach without the use of proxies. Distributed Virtual Environments: PDES-MAS has been the first one to address the problems of state partition, interest management and synchronisation in an integrated, adaptive and fully transparent manner.","title":"Overview"},{"location":"#get-pdes-mas","text":"Clone from github repository using git: git clone https://github.com/PDES-MAS/PDES-MAS.git","title":"Get PDES-MAS"},{"location":"api/","text":"Agent Programming Interface class Simulation method Construct Construct the simulation, with specifying number of CLPs, number of ALPs, and simulation start and end time. This is the step where MPI processes are created and forked from main process. After that, all codes executing will be at different MPI processes. method attach_alp_to_clp Attaches an ALP to a leaf CLP. This is typically controlled by users. If an ALP is not attached to a CLP, it will not be able to communicate to other process, and the simulation will exit with errors after it starts. method preload_variable Pre-loads variables into the shared states. Since PDES-MAS do not support dynamically adding or removing variables after the simulation has been started, all variables needed in the simulation must be initialised in advance using this method. The variable types supported are: integers, floats, strings, and 2D points (with two integers x, y). method Initialise After setting the attachment between ALPs and CLPs, and preloading all variables needed, the Initialise method initialises every MPI process as what it should be, ALP or CLP. It also used the data collected from previous user settings to initialise variables inside CLPs. method Run Start actually running the simulation. This includes starting the LP and running all threads needed inside it, such as message polling and sending. Note that agent threads is not started here. method Finalise The method executed when ending the simulation. This could either collect the logs, or just exit. method add_agent Adds agents to a ALP. When the method is called on a CLP process, nothing will happen. class Agent The agent inside ALPs are actually threads running concurrently. To program a agent, simply override the method Cycle in your own agent class inheriting the Agent class. method Cycle This is the main loop agent is going to execute. Inside this method, you need to use the data accessing methods provided by our agent programming interface to define the behaviour of your own agent. method SendGVTMessage This methods initiates GVT calculation across the whole system. Typically this is automatically controlled by the system and users won't need to touch this. If the GVT synchronization is too often, this may cause significant overhead thus slowing down the simulation. method time_wrap This method is used to step timestamps when user is not doing anything in a given time period. Since PDES-MAS itself is event-driven, this method will just increase the LVT of agent. method ReadInt Read an integer SSV. method ReadDouble Read a double SSV. method ReadPoint Read a 2D point SSV. method ReadString Read a string SSV. method WriteInt Modify an integer SSV. method WriteDouble Modify a double SSV. method WritePoint Modify a 2D point SSV. method WriteString Modify a string SSV. method RangeQueryPoint Perform range query in a given 2D rectangle range. Returns a list of point SSVs inside that range. method ReadPrivateInt Read an integer agent local variable. method ReadPrivateDouble Read a double agent local variable. method ReadPrivatePoint Read a 2D point agent local variable. method ReadPrivateString Read a string agent local variable. method WritePrivateInt Modify an integer agent local variable. method WritePrivateDouble Modify a double agent local variable. method WritePrivatePoint Modify a 2D point agent local variable. method WritePrivateString Modify a string agent local variable.","title":"Agent Programming Interface"},{"location":"api/#agent-programming-interface","text":"","title":"Agent Programming Interface"},{"location":"api/#class-simulation","text":"","title":"class Simulation"},{"location":"api/#method-construct","text":"Construct the simulation, with specifying number of CLPs, number of ALPs, and simulation start and end time. This is the step where MPI processes are created and forked from main process. After that, all codes executing will be at different MPI processes.","title":"method Construct"},{"location":"api/#method-attach_alp_to_clp","text":"Attaches an ALP to a leaf CLP. This is typically controlled by users. If an ALP is not attached to a CLP, it will not be able to communicate to other process, and the simulation will exit with errors after it starts.","title":"method attach_alp_to_clp"},{"location":"api/#method-preload_variable","text":"Pre-loads variables into the shared states. Since PDES-MAS do not support dynamically adding or removing variables after the simulation has been started, all variables needed in the simulation must be initialised in advance using this method. The variable types supported are: integers, floats, strings, and 2D points (with two integers x, y).","title":"method preload_variable"},{"location":"api/#method-initialise","text":"After setting the attachment between ALPs and CLPs, and preloading all variables needed, the Initialise method initialises every MPI process as what it should be, ALP or CLP. It also used the data collected from previous user settings to initialise variables inside CLPs.","title":"method Initialise"},{"location":"api/#method-run","text":"Start actually running the simulation. This includes starting the LP and running all threads needed inside it, such as message polling and sending. Note that agent threads is not started here.","title":"method Run"},{"location":"api/#method-finalise","text":"The method executed when ending the simulation. This could either collect the logs, or just exit.","title":"method Finalise"},{"location":"api/#method-add_agent","text":"Adds agents to a ALP. When the method is called on a CLP process, nothing will happen.","title":"method add_agent"},{"location":"api/#class-agent","text":"The agent inside ALPs are actually threads running concurrently. To program a agent, simply override the method Cycle in your own agent class inheriting the Agent class.","title":"class Agent"},{"location":"api/#method-cycle","text":"This is the main loop agent is going to execute. Inside this method, you need to use the data accessing methods provided by our agent programming interface to define the behaviour of your own agent.","title":"method Cycle"},{"location":"api/#method-sendgvtmessage","text":"This methods initiates GVT calculation across the whole system. Typically this is automatically controlled by the system and users won't need to touch this. If the GVT synchronization is too often, this may cause significant overhead thus slowing down the simulation.","title":"method SendGVTMessage"},{"location":"api/#method-time_wrap","text":"This method is used to step timestamps when user is not doing anything in a given time period. Since PDES-MAS itself is event-driven, this method will just increase the LVT of agent.","title":"method time_wrap"},{"location":"api/#method-readint","text":"Read an integer SSV.","title":"method ReadInt"},{"location":"api/#method-readdouble","text":"Read a double SSV.","title":"method ReadDouble"},{"location":"api/#method-readpoint","text":"Read a 2D point SSV.","title":"method ReadPoint"},{"location":"api/#method-readstring","text":"Read a string SSV.","title":"method ReadString"},{"location":"api/#method-writeint","text":"Modify an integer SSV.","title":"method WriteInt"},{"location":"api/#method-writedouble","text":"Modify a double SSV.","title":"method WriteDouble"},{"location":"api/#method-writepoint","text":"Modify a 2D point SSV.","title":"method WritePoint"},{"location":"api/#method-writestring","text":"Modify a string SSV.","title":"method WriteString"},{"location":"api/#method-rangequerypoint","text":"Perform range query in a given 2D rectangle range. Returns a list of point SSVs inside that range.","title":"method RangeQueryPoint"},{"location":"api/#method-readprivateint","text":"Read an integer agent local variable.","title":"method ReadPrivateInt"},{"location":"api/#method-readprivatedouble","text":"Read a double agent local variable.","title":"method ReadPrivateDouble"},{"location":"api/#method-readprivatepoint","text":"Read a 2D point agent local variable.","title":"method ReadPrivatePoint"},{"location":"api/#method-readprivatestring","text":"Read a string agent local variable.","title":"method ReadPrivateString"},{"location":"api/#method-writeprivateint","text":"Modify an integer agent local variable.","title":"method WritePrivateInt"},{"location":"api/#method-writeprivatedouble","text":"Modify a double agent local variable.","title":"method WritePrivateDouble"},{"location":"api/#method-writeprivatepoint","text":"Modify a 2D point agent local variable.","title":"method WritePrivatePoint"},{"location":"api/#method-writeprivatestring","text":"Modify a string agent local variable.","title":"method WritePrivateString"},{"location":"lp/","text":"Logical Process class Alp ALP (Agent Logical Process) is where the agent runs. Typically, an ALP would contain one or more agents. This could be configured when writing your own simulation. Agents inside ALPs are actually threads rather than MPI processes. But still, they runs in a asynchronous, non-blocking way. class Clp CLP (Communication Logical Process) is where the shared states are stored and all messages sent by agent will pass through one or more CLPs.","title":"Logical Process"},{"location":"lp/#logical-process","text":"","title":"Logical Process"},{"location":"lp/#class-alp","text":"ALP (Agent Logical Process) is where the agent runs. Typically, an ALP would contain one or more agents. This could be configured when writing your own simulation. Agents inside ALPs are actually threads rather than MPI processes. But still, they runs in a asynchronous, non-blocking way.","title":"class Alp"},{"location":"lp/#class-clp","text":"CLP (Communication Logical Process) is where the shared states are stored and all messages sent by agent will pass through one or more CLPs.","title":"class Clp"},{"location":"messages/","text":"Message Types In PDES-MAS, communication between LPs are designed to use Message . The messages have two categories: ControlMessage and SimulationMessage . ControlMessage is used to control the simulation process, thus has higher priority and is sent from LP to LP in a separate message queue. SimulationMessage is where the data exchange between agents and environments lives in. It could either be a request message, a response message or a anti message which is for reverting changes after a roll-back. class AbstractMessage This is the Abstract Base Class (ABC) from which all other message classes inherit. It defines some standard members which all messages contain. It also specifies two purely virtual methods send and receive which are defined in the three child classes. Each message sub class must also implement the CompareTo method. class AntiMessage Base class for all anti message classes. class ControlMessage Base class for all control message classes. A control message is NOT blocked by windows and its timestamp is NOT considered in GVT calculation. class EndMessage End message for an ALP. This is the EndMessage class used to indicate an agent has finished sending it's messages. This message has special routing, whereby it is routed through all ports except the one it came from. This is used by the shutdown procedure. The shutdown procedure uses GVT for the termination condition, the simulation is given a set end_time and when GVT=end_time the simulation can be safely terminated. Here, as in the previous approach each LP sends a termination message with a time-stamp = end_time of the simulation(NOTE end_time is usually set to time of last event plus one). This message must be broadcast to all CLPs (Not ALPs) in the system so as to update their LVT. After sending the termination message the ALP instigates a GVT calculation to determine the new GVT value. When the first agent does this GVT != end_time, although the LVT of the terminating agent = end_time and the LVT of all the CLPs = end_time, the LVT of all the other ALPs != end_time as none have sent their termination message. Using GVT in this way resolves the problem of transient messages as the GVT algorithm accounts for this. When all ALPs have sent their termination message the root CLP must periodically instigate gvt calculation. Once all transient messages have arrived and GVT is calculated as end_time it is safe to terminate. class GvtControlMessage Messages sent to each LP to decide their Mattern color, in order to do the GTV algorithm. class GvtMessage Base class for all GVT-related messages. class GvtRequestMessage Message sent by ALPs to initiate a GVT calculation. class GvtValueMessage Message reporting final negotiated GVT value back to each LP. class LoadBalancingMessage Originally designed to control load balancing between CLPs. Now replaced by StateMigrationMessage . class RangeQueryAntiMessage Anti message for range queries. class RangeQueryMessage Message to perform range queries, or contains the response of a range query. class RangeUpdateMessage Message to notify CLPs about range updates, typically after a variable has been changed, or when rollback and/or state migration happens. class ResponseMessage Base class of all response message classes A mixin class to distinguish all types of response message which is inherited from Simulation message class RollbackMessage Class which implements messages for rollback This is the class that implements the rollback message. It has a rollback Tag to identify the origin of a rollback (used to prevent the same LP from rolling back twice as a result of the same straggler). Rollback messages are generated by Clps, whereas anti-messages are generated by Alps. class SharedStateMessage Description: This is an abstract base class which all messages operating on the shared state inherit from. These messages are: - ReadMessage - WriteMessage - AddMessage - DelMessage This class adds the virtual method GenerateAntiMessage , which generates an equivalent AntiMessage from the normal non-anti-message class SimulationMessage Base class for all simulation message classes. Simulation message are blocked by windows and its timestamp is considered in GVT calculation. class SingleReadAntiMessage Anti message for single variable reads. class SingleReadMessage Class for reading a single SSV An instance of SingleReadMessage defines a message for an ALP reading the value of an individual Shared State Variable. class SingleReadResponseMessage Response of reading a single SSV. class StateMigrationMessage Message controls the migration of state variables between CLPs. Contain the variables to be migrated (maybe a empty list). class WriteAntiMessage Anti message for updating a single SSV. class WriteMessage Class for updating a single SSV. An instance of SingleReadMessage defines a message for an ALP updating the value of an individual Shared State Variable. A successful update will create a new write period at the destination CLP class WriteResponseMessage Response message for variable writes.","title":"Message Types"},{"location":"messages/#message-types","text":"In PDES-MAS, communication between LPs are designed to use Message . The messages have two categories: ControlMessage and SimulationMessage . ControlMessage is used to control the simulation process, thus has higher priority and is sent from LP to LP in a separate message queue. SimulationMessage is where the data exchange between agents and environments lives in. It could either be a request message, a response message or a anti message which is for reverting changes after a roll-back.","title":"Message Types"},{"location":"messages/#class-abstractmessage","text":"This is the Abstract Base Class (ABC) from which all other message classes inherit. It defines some standard members which all messages contain. It also specifies two purely virtual methods send and receive which are defined in the three child classes. Each message sub class must also implement the CompareTo method.","title":"class AbstractMessage"},{"location":"messages/#class-antimessage","text":"Base class for all anti message classes.","title":"class AntiMessage"},{"location":"messages/#class-controlmessage","text":"Base class for all control message classes. A control message is NOT blocked by windows and its timestamp is NOT considered in GVT calculation.","title":"class ControlMessage"},{"location":"messages/#class-endmessage","text":"End message for an ALP. This is the EndMessage class used to indicate an agent has finished sending it's messages. This message has special routing, whereby it is routed through all ports except the one it came from. This is used by the shutdown procedure. The shutdown procedure uses GVT for the termination condition, the simulation is given a set end_time and when GVT=end_time the simulation can be safely terminated. Here, as in the previous approach each LP sends a termination message with a time-stamp = end_time of the simulation(NOTE end_time is usually set to time of last event plus one). This message must be broadcast to all CLPs (Not ALPs) in the system so as to update their LVT. After sending the termination message the ALP instigates a GVT calculation to determine the new GVT value. When the first agent does this GVT != end_time, although the LVT of the terminating agent = end_time and the LVT of all the CLPs = end_time, the LVT of all the other ALPs != end_time as none have sent their termination message. Using GVT in this way resolves the problem of transient messages as the GVT algorithm accounts for this. When all ALPs have sent their termination message the root CLP must periodically instigate gvt calculation. Once all transient messages have arrived and GVT is calculated as end_time it is safe to terminate.","title":"class EndMessage"},{"location":"messages/#class-gvtcontrolmessage","text":"Messages sent to each LP to decide their Mattern color, in order to do the GTV algorithm.","title":"class GvtControlMessage"},{"location":"messages/#class-gvtmessage","text":"Base class for all GVT-related messages.","title":"class GvtMessage"},{"location":"messages/#class-gvtrequestmessage","text":"Message sent by ALPs to initiate a GVT calculation.","title":"class GvtRequestMessage"},{"location":"messages/#class-gvtvaluemessage","text":"Message reporting final negotiated GVT value back to each LP.","title":"class GvtValueMessage"},{"location":"messages/#class-loadbalancingmessage","text":"Originally designed to control load balancing between CLPs. Now replaced by StateMigrationMessage .","title":"class LoadBalancingMessage"},{"location":"messages/#class-rangequeryantimessage","text":"Anti message for range queries.","title":"class RangeQueryAntiMessage"},{"location":"messages/#class-rangequerymessage","text":"Message to perform range queries, or contains the response of a range query.","title":"class RangeQueryMessage"},{"location":"messages/#class-rangeupdatemessage","text":"Message to notify CLPs about range updates, typically after a variable has been changed, or when rollback and/or state migration happens.","title":"class RangeUpdateMessage"},{"location":"messages/#class-responsemessage","text":"Base class of all response message classes A mixin class to distinguish all types of response message which is inherited from Simulation message","title":"class ResponseMessage"},{"location":"messages/#class-rollbackmessage","text":"Class which implements messages for rollback This is the class that implements the rollback message. It has a rollback Tag to identify the origin of a rollback (used to prevent the same LP from rolling back twice as a result of the same straggler). Rollback messages are generated by Clps, whereas anti-messages are generated by Alps.","title":"class RollbackMessage"},{"location":"messages/#class-sharedstatemessage","text":"Description: This is an abstract base class which all messages operating on the shared state inherit from. These messages are: - ReadMessage - WriteMessage - AddMessage - DelMessage This class adds the virtual method GenerateAntiMessage , which generates an equivalent AntiMessage from the normal non-anti-message","title":"class SharedStateMessage"},{"location":"messages/#class-simulationmessage","text":"Base class for all simulation message classes. Simulation message are blocked by windows and its timestamp is considered in GVT calculation.","title":"class SimulationMessage"},{"location":"messages/#class-singlereadantimessage","text":"Anti message for single variable reads.","title":"class SingleReadAntiMessage"},{"location":"messages/#class-singlereadmessage","text":"Class for reading a single SSV An instance of SingleReadMessage defines a message for an ALP reading the value of an individual Shared State Variable.","title":"class SingleReadMessage"},{"location":"messages/#class-singlereadresponsemessage","text":"Response of reading a single SSV.","title":"class SingleReadResponseMessage"},{"location":"messages/#class-statemigrationmessage","text":"Message controls the migration of state variables between CLPs. Contain the variables to be migrated (maybe a empty list).","title":"class StateMigrationMessage"},{"location":"messages/#class-writeantimessage","text":"Anti message for updating a single SSV.","title":"class WriteAntiMessage"},{"location":"messages/#class-writemessage","text":"Class for updating a single SSV. An instance of SingleReadMessage defines a message for an ALP updating the value of an individual Shared State Variable. A successful update will create a new write period at the destination CLP","title":"class WriteMessage"},{"location":"messages/#class-writeresponsemessage","text":"Response message for variable writes.","title":"class WriteResponseMessage"},{"location":"ssv/","text":"State Variable class StateVariable is the modelling of shared variables in PDES-MAS.","title":"State Variable"},{"location":"ssv/#state-variable","text":"class StateVariable is the modelling of shared variables in PDES-MAS.","title":"State Variable"}]}